"""
This game uses funtions and assets previusly used by me
Previus project were created for pirple.com
The game is called "Super space pirate"
It can be viewed here on itch.oi - https://om3g4-247.itch.io/super-space-pirate
Or here on my github - https://github.com/OM3G424747/Game-Dev


Assets used for this game where found on PngJoy.com
Others were created by me in photoshop for "Super Space Pirate"

All assets were added to dropbox as an "assets" folder for Task 15

Classes were created outside of the game loop
this was values change be changed successfully

Values inside the game loop result in them being reset with each frame

"""

import pygame
import random
import pylint

screen_width = 1200  # sets width of display window
screen_height = 800  # sets height of display window
screen_title = "Basic Game"  # sets name for gamewindow

# preset basic colours set according to RGB - R 255 G 255 B 255

white_colour = (255, 255, 255)
black_colour = (0, 0, 0)
red_colour = (255, 0, 0)
yellow_colour = (255, 255, 0)
green_colour = (0, 255, 0)
blue_colour = (0, 0, 255)
grey_colour = (100, 100, 100)
lightgrey_colour = (200, 200, 200)

# sets clock for game frame rate
clock = pygame.time.Clock()

# the this generates random lists for use with the "Star Field Generator"
# each star field is randomly generated by randomly at the start of each game.
# changing total stars displayed will change based on total_stars variable
# more stars will result in lower performance
# X_pos and Y_pos = to set the position the star will be bisplayed
# the star_list_bool to determine if the star is near or far
# True values will read from the far_star_list_speed instead of star_list_speed
# higher speeds on closer stars create a 3D illusion.

total_stars = 100
star_list_x_pos = random.sample(range(1, screen_width), total_stars)
star_list_y_pos = random.sample(range(75, screen_height), total_stars)
star_list_speed = []  # used to generate speed for stars that seem closer
far_star_list_speed = []  # used to generate speed for stars that seem far away
star_list_bool = []  # list used to determine if a star is near or far
# generates bool values for the star list
for number in range(len(star_list_y_pos)):
    random_bool = random.randint(0, 1)
    if random_bool == 1:
        star_list_bool.append(True)
    elif random_bool == 0:
        star_list_bool.append(False)

# generates an int values for the star list
for star in range(len(star_list_y_pos)):
    random_speed = random.randint(4, 6)
    star_list_speed.append(random_speed)
# generates an int values for the star list
for star in range(len(star_list_y_pos)):
    random_speed = random.randint(1, 3)
    far_star_list_speed.append(random_speed)

# Jeck pack particles class -------------------------------------

# initiates particles class with lists needed to generate particles
# all lists are itterated over to create a particles effect
# destination_x_pos and destination_y_pos = current possition of particle
# change_to_red colour value changes from particle yellow to red
# value starts on 255 and is used on the position of "Green" for RGB
# The value is then decreased to slowly turn the particle red
# fade_colour is used on the "Red" colour position
# the counter value tracks time between particles.
# It delays the movement of particles so they are released gradually


class particles:

    def __init__(self):

        self.destination_x_pos = []
        self.destination_y_pos = []
        self.change_to_red = []
        self.fade_colour = []
        self.counter = 0

# the draw function for this class blits the particles / circles
# Values are appended at start
# player_y_dirction takes in a value of -1 or 1
# the y_postion of the particles changed by this value.
# This Y direction is changed if the player moves either up or down.
# the game_screen value passes the surface to be displayed on.
# This allows blit funtion to be used within this funtion

    def draw(self, x_pos, y_pos, player_y_direction, game_screen):

        self.game_screen = game_screen
        # negative 37 added to allign the particles with jetpack on the x_axis
        self.x_pos = int(x_pos) - 37
        # negative 37 added to allign the particles with jetpack on the y_axis
        self.y_pos = int(y_pos) - 30
        movement_speed = 9  # sets the default movement speed for particles
        colour_change = 50  # set's particle colour change speed
        # this sets the number particles to be generated
        self.number_of_particles = 25

        # for loop itterates over lists and appends values
        for num in range(self.number_of_particles):
            # changes the density of particle stream
            self.counter += 9

            # condition checks if lists are empty at start of game
            # then appends them combined with counter increments
            # this creates a more gradual flow of particles
            # removing counter condition will result in a sudden "burst"
            # the lists contain the starting values for each particle

            if (len(self.fade_colour) < self.number_of_particles and
                    self.counter >= 100):

                self.destination_x_pos.append(self.x_pos)
                self.destination_y_pos.append(self.y_pos)
                self.change_to_red.append(0)
                self.fade_colour.append(255)
                self.counter = 0

            # condition is not executed at game start

            elif num < len(self.fade_colour):
                # this checks if the particle is out of view

                if (self.fade_colour[num] == 0 or
                        self.destination_x_pos[num] < 0 or
                        self.destination_y_pos[num] > screen_height):

                    # lower value to increases particle flow
                    if self.counter >= 100:
                        self.destination_x_pos[num] = self.x_pos
                        self.destination_y_pos[num] = self.y_pos
                        self.change_to_red[num] = 255
                        self.fade_colour[num] = 255
                        # counter reset to 0
                        # delays the reset of the next particle
                        self.counter = 0

                # this condtion further increments the y_pos
                # 1 means the player is moving up and
                # results in the particles moving down faster
                # -1 means the player is moving down
                # results in the particles moving up faster

                elif (self.destination_x_pos[num] > 0 or
                        self.destination_y_pos[num] < screen_height):

                    if player_y_direction == 1:
                        self.destination_y_pos[num] += 10

                    elif player_y_direction == -1:
                        self.destination_y_pos[num] -= 10

                    # each X_pos and Y_pos in incremented
                    # random value to create a "fluttering effect"
                    self.destination_x_pos[num] -= (int(movement_speed 
                                                        - random.randint
                                                        (0, 2)))

                    self.destination_y_pos[num] += (int(movement_speed
                                                        - random.randint
                                                        (0, 15)))

                    # if the particles still hansn't fully changed red,
                    # the following condition passes as true
                    # the colour is further decreased with larger particle

                    if self.change_to_red[num] > 0:
                        self.change_to_red[num] -= colour_change
                        if self.change_to_red[num] < 0:
                            # sets to 0 to avoid errors
                            # negative values will cause errors
                            self.change_to_red[num] = 0
                        # a larger circle is displayed
                        # while the particle still has some "Green"
                        pygame.draw.circle(self.game_screen,
                                           (255, self.change_to_red[num], 0),
                                           (self.destination_x_pos[num],
                                            self.destination_y_pos[num]), 2)

                    # if the particles is red
                    # condition passes as true
                    # the colour red changed to black
                    # smaller particle being displayed

                    elif self.change_to_red[num] == 0:
                        if self.fade_colour[num] > 0:
                            # increments need to remain 15
                            # changing creates invalid colour
                            self.fade_colour[num] -= 15

                        # sets surface, colour and pos+size
                        # red particles size value = 1
                        pygame.draw.circle(self.game_screen,
                                           (self.fade_colour[num], 0, 0),
                                           (self.destination_x_pos[num],
                                            self.destination_y_pos[num]), 1)

# this creates a class for the player health bar
# the x_pos and y_pos = upper right corner
# total blocks determines the length
# more blocks = longer health bar with more hits
# changing block sizes = "density" and length
# colour changes from green to red
# colour is calculated by %
# damage counter animates the bar down


class health_bar:

    def __init__(self, x_pos, y_pos, total_blocks):

        self.full_colour = 255
        # set to true by condition to animate
        self.damage_taken = False
        # sets width of each health chunk
        self.chunks = 100
        # adds a final health to the health bar
        self.final_shot = 25
        self.health_bar_height = 70
        self.health_bar_width = self.final_shot + total_blocks * self.chunks
        # Total lenght the bar will be drawn
        self.total_blocks = total_blocks * self.chunks
        # counts the total damage taken
        self.total_damage = 0
        self.damage_counter = 0
        self.x_pos = x_pos
        self.y_pos = y_pos

    # this funtion displays the players health bar
    # it detects if the player is hit
    # the decreses the health bar size

    def draw(self, is_hit, game_screen):

        # condtion used to animate the healthbar
        # damaged incrementes counter
        # bigger increments = faster animations

        if self.damage_counter > 0:
            self.health_bar_width -= 5
            self.damage_counter -= 5

        # checks if the player is hit
        # and not recently damaged.
        # if true new hits can't be taken

        elif is_hit and not self.damage_taken:
            self.damage_taken = True

        # increments the total damage taken
        # and the damage counter for animation
        # damage can be taken again

        elif not is_hit and self.damage_taken:
            self.total_damage += self.chunks
            self.damage_counter += self.chunks
            self.damage_taken = False

        # percetentage of the colour to be reduced
        colour_reduction = self.full_colour / self.total_blocks
        # Used change value of green on RGB
        green = self.full_colour - (colour_reduction * self.total_damage)
        # Sets how much red will be added on RGB
        red = colour_reduction * self.total_damage
        # sets RGB colour for health bar
        self.colour = (int(red), int(green), 0)

        # draws an outline and hud for the player healthbar and goal display

        pygame.draw.rect(
            game_screen,
            lightgrey_colour,
            [0, 0, screen_width, 76]
            )

        pygame.draw.rect(
            game_screen,
            (50, 50, 50),
            [0, 0, screen_width, 74]
            )

        pygame.draw.rect(
            game_screen,
            (25, 25, 25),
            [self.x_pos - 5, self.y_pos,
            self.total_blocks + self.final_shot + 10, 74]
            )

        # displays remaining health bar
        if self.health_bar_width > self.final_shot:
            # sets grey under bar
            pygame.draw.rect(
                game_screen,
                grey_colour,
                [self.x_pos, self.y_pos,
                self.total_blocks + self.final_shot,
                self.health_bar_height]
                )

            # sets grey under bar to display the the length
            # colour based on the remaining chunks
            # sets colour and shape of bar

            pygame.draw.rect(
                game_screen,
                self.colour,
                [self.x_pos, self.y_pos,
                self.health_bar_width, self.health_bar_height]
                )

        # displayed when only one shot left
        # red value is passed to prevent error

        else:
            pygame.draw.rect(
                game_screen,
                grey_colour,
                [self.x_pos, self.y_pos,
                self.total_blocks + self.final_shot,
                self.health_bar_height]
                )

            pygame.draw.rect(
                game_screen,
                red_colour,
                [self.x_pos, self.y_pos,
                self.health_bar_width,
                self.health_bar_height]
                )

        # blits border for health bar
        # png transformed to quater scale

        game_screen.blit(
            pygame.transform.scale
            (pygame.image.load
            ("assets/health_hud.png"),
            (int(771 / 4), int(298 / 4))),
            (self.x_pos+135, self.y_pos)
            )

        game_screen.blit(
            pygame.transform.scale
            (pygame.image.load
            ("assets/health_hud_corner.png"),
            (int(771 / 4), int(298 / 4))),
            (self.x_pos - 5, self.y_pos)
            )

# it sets the width and heigh
# sets a spawn point to the far right
# based on screen width and the width of the object
# rotation list to determine if the object should rotate


class non_player_objects:

    def __init__(self, width, height, obstacle_png_namespace):

        self.width = width
        self.height = height
        self.spawn_point = screen_width + self.width
        self.x_pos_list = []
        self.y_pos_list = []
        self.speed_list = []
        self.rotation_list = []
        self.variant_list = []
        self.is_rotating_list = []
        self.name = obstacle_png_namespace
        self.image_path = f"assets/{obstacle_png_namespace}"

    # draws the non player objects
    # resets their X_pos if they reach end of screen
    # starting number sets the number of objects
    # the number of variants must = number of png files
    # is_rotating rotates object at random
    # player Y_direction move objects up or down

    def draw(self, starting_number,
             number_of_variants,
             is_rotating,
             player_y_direction,
             game_screen):

        # sets game screen variable to match the surface being passed
        self.game_screen = game_screen

        # variant number to change object png after the x_pos is reset

        self.starting_number = starting_number
        self.number_of_variants = random.randint(1, number_of_variants)

        # generates list values for number of objects to be displayed

        for num in range(self.starting_number):
            if len(self.x_pos_list) < self.starting_number:
                # set's starting rotation for image
                # 180 results in the image being flipped upside down
                self.rotation_list.append(random.randint(1, 180))
                # sets x_pos spawn point based on spawn point
                self.x_pos_list.append(self.spawn_point)
                # set's Y spawn point beteen 95 and screen height
                # 95 keeps it under the health bar
                self.y_pos_list.append(random.randint(95, screen_height))
                # speed object will be moving across screen and rotating
                self.speed_list.append(random.randint(6, 15))
                # selects random png variant for object
                self.variant_list.append(random.randint
                                         (1, self.number_of_variants))
                # generates random rotation
                # 0 = no rotation
                # 1 = clockwise rotation
                # 2= counter clockwise rotation
                self.is_rotating_list.append(random.randint(0, 2))

            # increments the y_pos based on player movement
            # 1 means the player is moving up
            # -1 means the player is moving down

            if player_y_direction == 1:
                self.y_pos_list[num] += 10

            elif player_y_direction == -1:
                self.y_pos_list[num] -= 10

            # moves object left accross screen
            self.x_pos_list[num] -= self.speed_list[num]

            # if rotation list is a 1, the object rotates clockwise
            if is_rotating and self.is_rotating_list[num] == 1:
                self.rotation_list[num] += (int
                                            (self.speed_list[num] / 2))

            # if rotation list is a 2, the object rotates counter clockwise
            else:
                if is_rotating and self.is_rotating_list[num] == 2:
                    self.rotation_list[num] -= (int
                                                (self.speed_list[num] / 2))

            # resets the object to the right
            # all are reset with new random values

            if self.x_pos_list[num] <= 0 - self.width:
                self.is_rotating_list[num] = random.randint(0, 2)
                self.rotation_list[num] = random.randint(1, 180)
                self.variant_list[num] = (random.randint
                                          (1, self.number_of_variants))

                self.y_pos_list[num] = (random.randint
                                        (95 + self.height, screen_height))
                self.speed_list[num] = random.randint(6, 15)
                self.x_pos_list[num] = self.spawn_point

            # creates image variable
            # loads the selected image based on the path
            # image is scaled to match width and height
            # copy is rotated based on speed value
            # X and Y pos is adjusted by half of the image height and width
            # this keeps the image centered during rotation

            self.image = pygame.image.load(f"{self.image_path}" +
                                           f"{self.variant_list[num]}.png")

            self.image = pygame.transform.scale(self.image,
                                                (self.width, self.height))

            self.image_copy = pygame.transform.rotate(self.image,
                                                      self.rotation_list[num])

            self.game_screen.blit(self.image_copy,
                                  (self.x_pos_list[num] -
                                   int(self.image_copy.get_width() / 2),
                                   self.y_pos_list[num] -
                                   int(self.image_copy.get_height() / 2)))

# creates the class for the player character
# the speed variable sets the speed at will move at accorss the screen
# higher speed will result in faster movement,
# but will also make the game easier and break animations
# x_pos and y_pos set the spawn point for the player.
# width and height set the center position where the player charercter


class player_character:

    def __init__(self, width, height):
        self.x_pos = 200
        self.y_pos = 400
        self.width = width
        self.height = height
        self.speed = 5

    # draw funtion draws the player characer based on dimentions and position.
    # x_pos + y_pos are reduced by half of the width and heigh
    # to center the image arround the specified position

    def draw(self, image_path, game_screen):
        self.image_path = image_path
        self.game_screen = game_screen
        self.image = pygame.transform.scale(pygame.image.load
                                            (self.image_path),
                                            (self.width, self.height))

        self.game_screen.blit(self.image,
                              (int(self.x_pos - (self.width / 2)),
                               int(self.y_pos - (self.height / 2))))

    # moves the player character based on the directions
    # increments the players position with the speed variable
    # movement is limted to max width and heigh

    def move(self, x_direction, y_direction, max_height, max_width):
        # used to make the player go up
        if y_direction > 0 and x_direction == 0:
            self.y_pos = self.y_pos - self.speed

        # Up and left combined
        elif y_direction > 0 and x_direction > 0:
            self.y_pos = self.y_pos - self.speed
            self.x_pos = self.x_pos - self.speed

        # Up and right combined
        elif y_direction > 0 and x_direction < 0:
            self.y_pos = self.y_pos - self.speed
            self.x_pos = self.x_pos + self.speed

        # used to make the player go down
        elif y_direction < 0 and x_direction == 0:
            self.y_pos = self.y_pos + self.speed

        # Down and left combined
        elif y_direction < 0 and x_direction > 0:
            self.y_pos = self.y_pos + self.speed
            self.x_pos = self.x_pos - self.speed

        # Down and right combined
        elif y_direction < 0 and x_direction < 0:
            self.y_pos = self.y_pos + self.speed
            self.x_pos = self.x_pos + self.speed

        # used to make the player go left
        elif x_direction > 0 and y_direction == 0:
            self.x_pos = self.x_pos - self.speed

        # used to make the player go right
        elif x_direction < 0 and y_direction == 0:
            self.x_pos = self.x_pos + self.speed

        # sets collision detection for bottom of the screen
        if self.y_pos >= max_height - 120:
            self.y_pos = max_height - 120

        # sets collision detection for top of the screen
        if self.y_pos <= 175:
            self.y_pos = 175

        # sets collision detects for right of the screen
        if self.x_pos >= max_width - 80:
            self.x_pos = max_width - 80

        # sets collision detection for left of the screen
        if self.x_pos <= 5:
            self.x_pos = 5

# collision class is used to generate hitboxes
# is_item bool = if the item is a collectable or not.
# if the bool is false, the item is an obstacle
# imapact variable get's set to true if collision is detected
# animation counter is incremented by the animate fuction
# list number returns the index number of the item that was hit
# object speed adjusts the animation X_pos so the animation maintains motion.


class collision():

    def __init__(self, is_item):

        self.is_item = is_item
        self.collision_pos = []
        self.collision_size = []
        self.impact = False
        self.animation_counter = 1
        self.list_number = 0
        self.object_speed = 0

    # collision box creates box based on shape and pos
    # if a collission is detected self.impact is set to true
    # no further boxes can theen be created
    # pos along with width and heigh are saved to variable upon impact

    def collision_box(self, object_speed_list,
                      x_pos_list, y_pos_list,
                      object_width, object_height,
                      player_x_pos, player_y_pos,
                      player_width, player_height):

        if not self.impact:

            for pos in range(len(x_pos_list)):

                if (x_pos_list[pos] < player_x_pos + player_width and
                        x_pos_list[pos] + object_width > player_x_pos):

                    if (y_pos_list[pos] < player_y_pos + player_height and
                            y_pos_list[pos] + object_height > player_y_pos):

                        self.collision_pos = [
                            x_pos_list[pos],
                            y_pos_list[pos]
                            ]

                        # 50 expands animation size width further
                        self.collision_size = [
                            object_width + 50,
                            object_height
                            ]

                        # item animations maintain constant speed
                        if self.is_item:
                            self.object_speed = 18

                        # obstacles colision animation
                        # half their origian movement
                        else:
                            self.object_speed = int(object_speed_list[pos] / 2)

                        self.list_number = pos
                        self.impact = True

    # y_direction of the player moves the animation up or down
    # uses pos passed by collision box along with width and height

    def animate(self, player_y_direction, game_screen):

        # animation for items after being collected by the player
        # image is stretches out and moved over the mech

        if self.impact and self.is_item:

            self.collision_size[1] += 100

            if player_y_direction == 1:
                self.collision_pos[1] += 10

            elif player_y_direction == - 1:
                self.collision_pos[1] -= 10
            self.collision_pos[1] -= 50
            self.collision_pos[0] -= self.object_speed
            if self.collision_size[0] - 15 < 0:
                self.collision_size[0] = 0

                # false = allow further collision boxes to be created for items
                self.impact = False

            else:
                self.collision_size[0] -= 15

            # blits image based on current animation parameters
            game_screen.blit(pygame.transform.scale
                             (pygame.image.load
                              ("assets/lazer.png"),
                              (self.collision_size[0],
                               self.collision_size[1] + 50)),
                             (self.collision_pos[0] - 50,
                              self.collision_pos[1] - 45))

        # animation for objects after being hit by the player
        # animation counter incremented to display a new image
        # size is increased to appear as though expanding
        # position is adjusted to keep the image centered

        elif self.impact and not self.is_item:

            self.collision_size[0] += 10
            self.collision_size[1] += 10
            # centers animation as based on half of it's increased size
            self.collision_pos[0] -= 5
            self.collision_pos[1] -= 5

            # moves the animation along by the object speed that was passed
            self.collision_pos[0] -= self.object_speed

            # increments the y_pos of each particle based on the Y_direction
            # 1 means the player is moving up
            # -1 means the player is moving down

            if player_y_direction == 1:
                self.collision_pos[1] += 10

            elif player_y_direction == -1:
                self.collision_pos[1] -= 10

            # blits image based on current animation parameters
            game_screen.blit(pygame.transform.scale
                             (pygame.image.load
                              (f"assets/boom{self.animation_counter}.png"),
                              (self.collision_size[0],
                               self.collision_size[1] + 50)),
                             (self.collision_pos[0] - 50,
                              self.collision_pos[1] - 45))

            # resets animation after 24 frames have been reached
            # sets impact to false to allow a new collision box to be created
            if self.animation_counter == 24:
                self.animation_counter = 1
                self.impact = False
            else:
                # increments animation counter to display next animation frame
                self.animation_counter += 1

# GAME CLASS AND LOOP --------------------------------------------------------

# main game class, set's the values for the main game loop


class game:

    tick_rate = 30  # Change to set framerate

    # passes the title for game
    # along with the width and height for the game window
    def __init__(self, title, width, height):
        self.title = title
        self.width = width
        self.height = height

        # creates game window based on passed values
        # creates the window being displayed
        self.game_screen = pygame.display.set_mode((width, height))
        # sets the default colour of the displayed window
        self.game_screen.fill(black_colour)
        pygame.display.set_caption(title)

    # creates funtion for main game loop
    def run_game_loop(self):

        # game continues to player while the value remains false
        game_over = False
        # checks if the player won the game
        player_won = False
        # checks if the player is on the main menu
        menu = True
        # check the player has started the game
        start_game = False
        # set's the y and x direction based on key input
        y_direction = 0
        x_direction = 0
        # increments for animation of jetpack fire and mech
        counter = 0
        # delays initial spawn of obstacles and items
        distance_counter = 0
        # set's is_item variable value to true
        is_item = True
        # used to detect if the player is hit
        player_hit = False
        # used to detect if the player collected an item
        player_point = False
        # used to track player score
        player_score = 0
        # set's player chucks for health bar, does not include final shot.
        # 3 mean the player can take 4 shots total before they lose
        player_hit_points = 3
        # set platyer character height and width
        player1 = player_character(165, 155)
        # set player character jetpack fire height and width
        jetfire = player_character(165, 155)
        # adjusting jetpack sprite to better allign with player character
        jetfire.y_pos = player1.y_pos - 4
        # creates jetpack sparks variable with the particles class
        jetpack_sparks = particles()
        # creates meteors with the non_player_objects class
        meteor = non_player_objects(50, 50, "meteor")
        # creates collectable items with the non_player_objects class
        parts = non_player_objects(35, 35, "parts")
        # creates a player health bar with the health bar class
        player_health = health_bar(870, 0, player_hit_points)
        # creates starting variables for items and meteors
        # used to create a hit box with the collision class
        meteor_damage = collision(not is_item)
        player_item = collision(is_item)

# start of game loop  ----------------------------------------------------
        while not game_over:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    game_over = True

# CONTROLLS -------------------------------------------------------------
                # changes get_pressed funtion into a list list called keys
                keys = pygame.key.get_pressed()

                # directional boools for
                # changed by W,A,S,D and arrow keys
                pressed_up = False
                pressed_down = False
                pressed_left = False
                pressed_right = False

                # changes direction bools based on the key pressed
                if keys[pygame.K_UP] or keys[pygame.K_w]:
                    pressed_up = True
                elif not keys[pygame.K_UP] or not keys[pygame.K_w]:
                    pressed_up = False

                if keys[pygame.K_DOWN] or keys[pygame.K_s]:
                    pressed_down = True
                elif not keys[pygame.K_DOWN] or not keys[pygame.K_s]:
                    pressed_down = False

                if keys[pygame.K_LEFT] or keys[pygame.K_a]:
                    pressed_left = True
                elif not keys[pygame.K_LEFT] or not keys[pygame.K_a]:
                    pressed_left = False

                if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
                    pressed_right = True
                elif not keys[pygame.K_RIGHT] or not keys[pygame.K_d]:
                    pressed_right = False

                # if neither the up or down bools are true
                # direction is reset to 0 for y
                # stops the player moving up or down
                if not pressed_up and not pressed_down:
                    y_direction = 0

                # if neither the left or right bools are true
                # direction is reset to 0 for x
                # stop the player moving left or right
                if not pressed_left and not pressed_right:
                    x_direction = 0

                if pressed_up:  # checks for Up arrow key to change y_direction
                    y_direction = 1
                    # checks for combined Up and Left arrow key
                    if pressed_up and pressed_left:
                        y_direction = 1
                        x_direction = 1
                    # Checks for combined Up and Right arrow key
                    elif pressed_up and pressed_right:
                        y_direction = 1
                        x_direction = -1
                # Checks for Down arrow key
                elif pressed_down:
                    y_direction = -1
                    # Checks for combined Down and Left arrow key
                    if pressed_down and pressed_left:
                        y_direction = -1
                        x_direction = 1
                    # Checks for combined Down and Right arrow key
                    elif pressed_down and pressed_right:
                        y_direction = -1
                        x_direction = -1
                elif pressed_right:  # Checks for Right arrow key
                    x_direction = -1
                elif pressed_left:  # Checks for Left arrow key
                    x_direction = 1

                # reduces direction to 0 after keys are released

# Star Generator Funtion ----------------------------------------------

            # generates star background
            # uses lists generated at the top for stars
            # star generator blits stars onto screen

            def star_generator():

                # used to generate stars based on the number selected
                for num in range(len(star_list_x_pos)):

                    # conditions for "near stars"
                    # uses larger variables and circle size than far stars
                    if star_list_bool[num - 1]:
                        # used to make the stars flicker brighter
                        near_ficker_colour = random.randint(120, 180)
                        # sets new colour for the specified star in the loop
                        near_flicker_star = (
                            near_ficker_colour,
                            near_ficker_colour,
                            near_ficker_colour
                            )

                        pygame.draw.circle(
                            self.game_screen,
                            near_flicker_star,
                            (star_list_x_pos[num - 1],
                             star_list_y_pos[num - 1]), 2)

                    # conditions for "far stars"
                    # uses smaller variables and circle size than near stars
                    elif not star_list_bool[num - 1]:
                        # used to make the stars flicker more dim
                        far_ficker_colour = random.randint(50, 100)
                        # sets new colour for the specified star in the loop
                        far_flicker_star = (
                            far_ficker_colour,
                            far_ficker_colour,
                            far_ficker_colour
                            )

                        pygame.draw.circle(
                            self.game_screen,
                            far_flicker_star,
                            (star_list_x_pos[num - 1],
                             star_list_y_pos[num - 1]), 1)

            # create funtion to move stars based on player movement

            def star_move(player_y_direction):

                for num in range(len(star_list_x_pos)):

                    # star position is incremented with a greater speed
                    # used for near stars
                    if star_list_bool[num]:
                        star_list_x_pos[num] = (star_list_x_pos[num]
                                                - star_list_speed[num])

                        # Up movement from player makes the stars move down
                        if player_y_direction == 1:
                            star_list_y_pos[num] = (star_list_y_pos[num]
                                                    + star_list_speed[num])

                        # Down movement from player to make the stars move up
                        elif player_y_direction == -1:
                            star_list_y_pos[num] = (star_list_y_pos[num]
                                                    - star_list_speed[num])

                    # star position is incremented with a slower speed
                    # used for far stars
                    elif not star_list_bool[num]:
                        star_list_x_pos[num] = (star_list_x_pos[num]
                                                - far_star_list_speed[num])

                        # Up movement from player makes the stars move down
                        if player_y_direction == 1:
                            star_list_y_pos[num] = (star_list_y_pos[num]
                                                    + far_star_list_speed[num])

                        # Down movement from player to make the stars move up
                        elif player_y_direction == -1:
                            star_list_y_pos[num] = (star_list_y_pos[num]
                                                    - far_star_list_speed[num])

                    # reset the stars pos

                    if star_list_y_pos[num] >= screen_height:
                        # moves stars to the top of the screen
                        star_list_y_pos[num] = 0

                    elif star_list_y_pos[num] <= 0:
                        # moves stars to the bottom of the screen
                        star_list_y_pos[num] = screen_height

                    elif star_list_x_pos[num] <= 0:
                        # moves stars to the right of the screen again
                        star_list_x_pos[num] = screen_width

# Menu  -------------------------------------------------------------
            # displays the menu image for the player
            # any enter key starts the game
            if menu:
                self.game_screen.blit(
                    pygame.image.load(
                        "assets/start_screen.png"), (0, 0))

                if keys[pygame.K_RETURN] or keys[pygame.K_KP_ENTER]:
                    start_game = True
                    menu = False

# Main Game  ---------------------------------------------------------

            # af the player hits enter the main game starts
            elif start_game:
                # increments distance counter once per frame
                distance_counter += 1

                # checks if the player collected an item
                # the player's score is then incremented
                # the point bool is set to false
                # this allows another point to be collected

                if player_point and not player_item.impact:
                    player_score += 1
                    parts.x_pos_list[0] = 0 - parts.width
                    player_point = False

                # set's background colour to black
                self.game_screen.fill(black_colour)

                # randomly selects a new flame for jeckpack with each frame
                back_pack_flame_frame = random.randint(0, 3)

                # generates stars by calling the star_generator funtion
                star_generator()
                star_move(y_direction)

                # draws jetpack sparks
                jetpack_sparks.draw(
                    player1.x_pos,
                    player1.y_pos,
                    y_direction,
                    self.game_screen
                    )

                # draws jetpack flame over sparks
                jetfire.draw(
                    f"assets/fire{back_pack_flame_frame}.png",
                    self.game_screen
                    )

                # shield is displayed to show temp protection
                # no shield is displayed after the final hit
                if (player_hit and
                        player_health.total_damage <
                        player_health.total_blocks -
                        player_health.final_shot):

                    # displays with every 2nd digit to make the shield flash
                    if counter % 2 == 0:
                        self.game_screen.blit(pygame.transform.scale(
                                pygame.image.load(
                                    "assets/shield.png"), (155, 155)),
                                        (player1.x_pos - 85,
                                         player1.y_pos - 75))

                # animates's player characer mech
                if counter <= 1:
                    player1.draw(f"assets/player{0}.png", self.game_screen)

                # only draws a new fram with every 2nd
                elif counter >= 2:
                    player1.draw(f"assets/player{int(counter / 2)}.png",
                                 self.game_screen)

                # creates delay before objects and items are spawned
                if distance_counter >= 100:
                    # draws meteor objects
                    meteor.draw(4, 3, True, y_direction, self.game_screen)

                    # checks for collision with meteor
                    # sets the player_hit bool to true
                    # triggers the health bar reduction
                    # additional changes made in the parameters
                    # calibrate the box size and postion
                    meteor_damage.collision_box(
                        meteor.speed_list,
                        meteor.x_pos_list,
                        meteor.y_pos_list,
                        meteor.width,
                        meteor.height,
                        player1.x_pos - (player1.width / 2) + 100,
                        player1.y_pos - 40,
                        player1.width - 105,
                        player1.height - 35
                        )

                    # animates the meteor exploding
                    meteor_damage.animate(y_direction, self.game_screen)

                    # check impact variable from collision class
                    # if true the player hit bool is set to true
                    # the meteor is moved to the left to respawn
                    if meteor_damage.impact:
                        player_hit = True
                        num = meteor_damage.list_number
                        meteor.x_pos_list[num] = (0 - meteor.width)

                    # after player impact is false
                    # player hit also turns to false
                    # reduces the player hitpoints by 1
                    # changes the player hit to false to allow another hit
                    elif player_hit and not meteor_damage.impact:
                        player_hit_points -= 1
                        player_hit = False

                    # checks for collision with "parts"
                    # increments the player's score
                    # additional changes made in the parameters
                    # calibrate the box size and postion
                    player_item.collision_box(
                        parts.speed_list,
                        parts.x_pos_list,
                        parts.y_pos_list,
                        parts.width,
                        parts.height,
                        player1.x_pos - (player1.width / 2) + 100,
                        player1.y_pos - 40, player1.width - 105,
                        player1.height - 35
                        )

                    # animates the item if it's not impacting with the player
                    # after impact it's moved to the far left to respawn
                    if not player_item.impact and not player_point:
                        parts.draw(1, 4, False, y_direction, self.game_screen)
                    # creates an animation for item collection
                    elif player_item.impact:
                        player_item.animate(y_direction, self.game_screen)

                        player_point = True

                # changes player position based on x and y direction
                player1.move(
                    x_direction,
                    y_direction,
                    screen_height,
                    screen_width
                    )

                # resets jetfire width and height with each new frame
                jetfire.width = 165
                jetfire.height = 155

                # condtions to warp the jetfire height and width
                jetfire_shape_warp = random.randint(0, 4)
                if jetfire_shape_warp == 0:
                    jetfire.height += 15
                elif jetfire_shape_warp == 1:
                    jetfire.height -= 15
                elif jetfire_shape_warp == 2:
                    jetfire.width += 15
                elif jetfire_shape_warp == 3:
                    jetfire.width -= 15

                # funtion to move the jetfire based on player direction
                jetfire.move(
                    x_direction,
                    y_direction,
                    screen_height,
                    screen_width)

                # counter get's incremented for animation
                if counter == 48:
                    counter = 0
                elif counter < 48:
                    if counter <= 23:
                        jetfire.y_pos += 0.25
                    elif counter >= 24:
                        jetfire.y_pos -= 0.25
                    counter += 1

                # health bar funtion to check if the player is hit
                # reduces the health bar
                player_health.draw(player_hit, self.game_screen)

                # creates outline box arround mission goal to collect parts
                pygame.draw.rect(
                    self.game_screen,
                    (25, 25, 25),
                    [5, 5, 760, 60]
                    )

                pygame.draw.rect(
                    self.game_screen,
                    (200, 200, 200),
                    [10, 10, 750, 50]
                    )

                self.game_screen.blit(pygame.image.load(
                    "assets/goal_title.png"),
                    (-85, -5)
                    )

                if player_health.total_damage > player_health.total_blocks:
                    start_game = False

                # conditions to change number being displayed for goal
                elif player_score < 10:
                    self.game_screen.blit(pygame.image.load(
                        f"assets/goal{10 - player_score}.png"),
                        (680, -5)
                        )

                elif player_score >= 10:
                    start_game = False
                    player_won = True

# Win / Lose conditions ------------------------------------------------

            # displays win or loose screen
            elif not menu and not start_game:
                # "enter" starts over and returns to the main menu

                if player_won:
                    self.game_screen.blit(pygame.image.load(
                        "assets/player_win.png"),
                         (0, 0)
                         )

                    if keys[pygame.K_RETURN]:
                        pygame.init()
                        # creates a new game part of the "game class"
                        new_game = game(
                            screen_title,
                            screen_width,
                            screen_height)

                        # restarts game loop
                        new_game.run_game_loop()
                        pygame.quit()
                        quit()

                else:
                    self.game_screen.blit(pygame.image.load(
                        "assets/player_lose.png"),
                        (0, 0)
                        )

                    if keys[pygame.K_RETURN]:
                        pygame.init()
                        # creates a new game part of the "game class"
                        new_game = game(
                            screen_title,
                            screen_width,
                            screen_height)

                        # restarts game loop
                        new_game.run_game_loop()
                        pygame.quit()
                        quit()

            # end of loop code updates the fram and incrementes the clock
            # Updates the current frame after completing the loop
            pygame.display.update()
            # Sets the frame rate per second
            clock.tick(self.tick_rate)


pygame.init()

# creates a new game part of the "game class"
new_game = game(screen_title, screen_width, screen_height)

# Starts the game loop as defined in the class
# continues looping until the "game over" state becomes true
new_game.run_game_loop()

pygame.quit()
quit()
